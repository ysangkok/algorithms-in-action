Global alignment of two strings finds the best alignment of the two strings, starting at the beginning of both strings and ending at the ends of both strings.  Any misalignments at the ends count as delections/insertions.

Using edit distance as our measure of the difference between the two strings, we are looking for the alignment with the least edit difference.  Edit distance allows for a cost for each mismatch, and a cost for indels.  The cost for insertions and deletion, ``indels'', must be the same, since we are not claiming a directional difference. Matches, of course, do not have a cost.

We use a dynamic programming algorithms, which is based on the idea that if we know the best alignment up to the (i-1)th position of the alignment, then we can compute the best alignment at the (i)th position.  The cost of the alignment at the ith position is the cost of the best alignment up to the (i-1)th position, plus the minimum of the the following three costs: the cost of aligning the next position in both sequences (matching or mismatching); the cost of aligning the next position in string1 against a deletion, or blank, in string2; the cost of adding the next position in string2 as an insertion against a blank in string1.  The best value is then inserted into the table of costs.  In addition, a pointer to the previous best position indicates whether the current best position was achieved by a match/mismatch, an insertion, or a deletion.  Where the least edit difference can be achieved in more than one way, multiple pointers are kept.

When we have come to the end of both strings, the cost of the best alignment(s) is in the cell at table[n,m].  To get the best alignment or alignments, we trace back using the pointers that were inserted during the build process.

Where gaps are modelled as a gap cost plus an extension cost, instead of simply as a series of indels, the algorithm gets much more complicated.  Three arrays must be kept, to keep track of the cost depending on whether we just ended in a no-gap situation, a gap in string1 or a gap in string2.  This is necessary, because a following gap would be costed differently, depending on the previous situation.
